<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>xwiimote: Device Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xwiimote
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__device.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Device Interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>Communication between applications and devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7d37d56ea1fb9002946bcf1863f54545"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga7d37d56ea1fb9002946bcf1863f54545">XWII_LED</a>(num)&#160;&#160;&#160;(XWII_LED1 + (num) - 1)</td></tr>
<tr class="memdesc:ga7d37d56ea1fb9002946bcf1863f54545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create enum xwii_led constants during runtime.  <a href="#ga7d37d56ea1fb9002946bcf1863f54545">More...</a><br/></td></tr>
<tr class="separator:ga7d37d56ea1fb9002946bcf1863f54545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga781852d892d1184331701a9147497d91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga781852d892d1184331701a9147497d91">xwii_iface_type</a> { <br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a1d50c36edc089416557d814398f66a02">XWII_IFACE_CORE</a> = 0x000001, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91aeaecff3a5dcd70b941a36483c6fdf6c9">XWII_IFACE_ACCEL</a> = 0x000002, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91ad86c46c0dee8fc8755e7304a8ee5bbbb">XWII_IFACE_IR</a> = 0x000004, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a8d9bed7f2ccad79149f6d2aff1b37081">XWII_IFACE_MOTION_PLUS</a> = 0x000100, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91aa2f1390c3ed47b404b3c241632435916">XWII_IFACE_NUNCHUK</a> = 0x000200, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a5ebe169cd83e389c9178e3030244c439">XWII_IFACE_CLASSIC_CONTROLLER</a> = 0x000400, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a55080e2c6b453a1055692d01f4e57866">XWII_IFACE_BALANCE_BOARD</a> = 0x000800, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a2fbaf95f53fb6c37418104434c690fec">XWII_IFACE_PRO_CONTROLLER</a> = 0x001000, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91a563ca6a91f8288fab92418bbcf0ef99e">XWII_IFACE_ALL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91ab6447f677b72d4842de2476921b31b1e">XWII_IFACE_WRITABLE</a> = 0x010000
<br/>
 }</td></tr>
<tr class="memdesc:ga781852d892d1184331701a9147497d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interfaces.  <a href="group__device.html#ga781852d892d1184331701a9147497d91">More...</a><br/></td></tr>
<tr class="separator:ga781852d892d1184331701a9147497d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2498fc0f02df2f6f59632808a70b15a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaf2498fc0f02df2f6f59632808a70b15a">xwii_led</a> { <br/>
&#160;&#160;<b>XWII_LED1</b> = 1, 
<br/>
&#160;&#160;<b>XWII_LED2</b> = 2, 
<br/>
&#160;&#160;<b>XWII_LED3</b> = 3, 
<br/>
&#160;&#160;<b>XWII_LED4</b> = 4
<br/>
 }</td></tr>
<tr class="memdesc:gaf2498fc0f02df2f6f59632808a70b15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEDs.  <a href="group__device.html#gaf2498fc0f02df2f6f59632808a70b15a">More...</a><br/></td></tr>
<tr class="separator:gaf2498fc0f02df2f6f59632808a70b15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa3e9517734189fe581dde3bb89e81d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaa3e9517734189fe581dde3bb89e81d09">xwii_iface_new</a> (struct xwii_iface **dev, const char *syspath)</td></tr>
<tr class="memdesc:gaa3e9517734189fe581dde3bb89e81d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new device object from syspath path.  <a href="#gaa3e9517734189fe581dde3bb89e81d09">More...</a><br/></td></tr>
<tr class="separator:gaa3e9517734189fe581dde3bb89e81d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de406d4fa9bd58c8e6bc752aaf46afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga7de406d4fa9bd58c8e6bc752aaf46afa">xwii_iface_ref</a> (struct xwii_iface *dev)</td></tr>
<tr class="memdesc:ga7de406d4fa9bd58c8e6bc752aaf46afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase ref-count by 1.  <a href="#ga7de406d4fa9bd58c8e6bc752aaf46afa">More...</a><br/></td></tr>
<tr class="separator:ga7de406d4fa9bd58c8e6bc752aaf46afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92196dc992decb4e1125af750d1bfe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaf92196dc992decb4e1125af750d1bfe8">xwii_iface_unref</a> (struct xwii_iface *dev)</td></tr>
<tr class="memdesc:gaf92196dc992decb4e1125af750d1bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease ref-count by 1.  <a href="#gaf92196dc992decb4e1125af750d1bfe8">More...</a><br/></td></tr>
<tr class="separator:gaf92196dc992decb4e1125af750d1bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bdc11457b4a6b84d16a4c82239b3a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gae0bdc11457b4a6b84d16a4c82239b3a5">xwii_iface_get_fd</a> (struct xwii_iface *dev)</td></tr>
<tr class="memdesc:gae0bdc11457b4a6b84d16a4c82239b3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return file-descriptor.  <a href="#gae0bdc11457b4a6b84d16a4c82239b3a5">More...</a><br/></td></tr>
<tr class="separator:gae0bdc11457b4a6b84d16a4c82239b3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e8f9b73053d1603033d3a4fd067101"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga27e8f9b73053d1603033d3a4fd067101">xwii_iface_watch</a> (struct xwii_iface *dev, bool watch)</td></tr>
<tr class="memdesc:ga27e8f9b73053d1603033d3a4fd067101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watch device for hotplug events.  <a href="#ga27e8f9b73053d1603033d3a4fd067101">More...</a><br/></td></tr>
<tr class="separator:ga27e8f9b73053d1603033d3a4fd067101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432d767dc77b12aa6f86f1d784174a28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga432d767dc77b12aa6f86f1d784174a28">xwii_iface_open</a> (struct xwii_iface *dev, unsigned int ifaces)</td></tr>
<tr class="memdesc:ga432d767dc77b12aa6f86f1d784174a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open interfaces on this device.  <a href="#ga432d767dc77b12aa6f86f1d784174a28">More...</a><br/></td></tr>
<tr class="separator:ga432d767dc77b12aa6f86f1d784174a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9a605d36b93af451102c03c468a9ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaca9a605d36b93af451102c03c468a9ab">xwii_iface_close</a> (struct xwii_iface *dev, unsigned int ifaces)</td></tr>
<tr class="memdesc:gaca9a605d36b93af451102c03c468a9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close interfaces on this device.  <a href="#gaca9a605d36b93af451102c03c468a9ab">More...</a><br/></td></tr>
<tr class="separator:gaca9a605d36b93af451102c03c468a9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb9507830c554ba34c30a053fd62baf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaffb9507830c554ba34c30a053fd62baf">xwii_iface_opened</a> (struct xwii_iface *dev)</td></tr>
<tr class="memdesc:gaffb9507830c554ba34c30a053fd62baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return bitmask of opened interfaces.  <a href="#gaffb9507830c554ba34c30a053fd62baf">More...</a><br/></td></tr>
<tr class="separator:gaffb9507830c554ba34c30a053fd62baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ea234eb0b67ede2c5cb68576ddf0f7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaa0ea234eb0b67ede2c5cb68576ddf0f7">xwii_iface_available</a> (struct xwii_iface *dev)</td></tr>
<tr class="memdesc:gaa0ea234eb0b67ede2c5cb68576ddf0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return bitmask of available interfaces.  <a href="#gaa0ea234eb0b67ede2c5cb68576ddf0f7">More...</a><br/></td></tr>
<tr class="separator:gaa0ea234eb0b67ede2c5cb68576ddf0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc90a7e6d0e40c2b250c7799c7f37b42"><td class="memItemLeft" align="right" valign="top">XWII__DEPRECATED int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gadc90a7e6d0e40c2b250c7799c7f37b42">xwii_iface_poll</a> (struct xwii_iface *dev, struct <a class="el" href="structxwii__event.html">xwii_event</a> *ev)</td></tr>
<tr class="memdesc:gadc90a7e6d0e40c2b250c7799c7f37b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read incoming event-queue.  <a href="#gadc90a7e6d0e40c2b250c7799c7f37b42">More...</a><br/></td></tr>
<tr class="separator:gadc90a7e6d0e40c2b250c7799c7f37b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadebbb6a2f7f9b579552f04ec7e06ae9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaadebbb6a2f7f9b579552f04ec7e06ae9">xwii_iface_dispatch</a> (struct xwii_iface *dev, struct <a class="el" href="structxwii__event.html">xwii_event</a> *ev, size_t size)</td></tr>
<tr class="memdesc:gaadebbb6a2f7f9b579552f04ec7e06ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read incoming event-queue.  <a href="#gaadebbb6a2f7f9b579552f04ec7e06ae9">More...</a><br/></td></tr>
<tr class="separator:gaadebbb6a2f7f9b579552f04ec7e06ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695ed40bc40c90a6935472dc9b4db181"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga695ed40bc40c90a6935472dc9b4db181">xwii_iface_rumble</a> (struct xwii_iface *dev, bool on)</td></tr>
<tr class="memdesc:ga695ed40bc40c90a6935472dc9b4db181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle rumble motor.  <a href="#ga695ed40bc40c90a6935472dc9b4db181">More...</a><br/></td></tr>
<tr class="separator:ga695ed40bc40c90a6935472dc9b4db181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02ef7934408cd3938b2c4bc2d07d4d10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga02ef7934408cd3938b2c4bc2d07d4d10">xwii_iface_get_led</a> (struct xwii_iface *dev, unsigned int led, bool *state)</td></tr>
<tr class="memdesc:ga02ef7934408cd3938b2c4bc2d07d4d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read LED state.  <a href="#ga02ef7934408cd3938b2c4bc2d07d4d10">More...</a><br/></td></tr>
<tr class="separator:ga02ef7934408cd3938b2c4bc2d07d4d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d9f2430ddd7f4940feb3cbc20267f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gab9d9f2430ddd7f4940feb3cbc20267f3">xwii_iface_set_led</a> (struct xwii_iface *dev, unsigned int led, bool state)</td></tr>
<tr class="memdesc:gab9d9f2430ddd7f4940feb3cbc20267f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LED state.  <a href="#gab9d9f2430ddd7f4940feb3cbc20267f3">More...</a><br/></td></tr>
<tr class="separator:gab9d9f2430ddd7f4940feb3cbc20267f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7e94790780b3bd9fd38d6f59d296d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#gaea7e94790780b3bd9fd38d6f59d296d9">xwii_iface_get_battery</a> (struct xwii_iface *dev, uint8_t *capacity)</td></tr>
<tr class="memdesc:gaea7e94790780b3bd9fd38d6f59d296d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read battery state.  <a href="#gaea7e94790780b3bd9fd38d6f59d296d9">More...</a><br/></td></tr>
<tr class="separator:gaea7e94790780b3bd9fd38d6f59d296d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e1f2c199ec478278267f0e48b00321"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga73e1f2c199ec478278267f0e48b00321">xwii_iface_get_devtype</a> (struct xwii_iface *dev, char **devtype)</td></tr>
<tr class="memdesc:ga73e1f2c199ec478278267f0e48b00321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read device type.  <a href="#ga73e1f2c199ec478278267f0e48b00321">More...</a><br/></td></tr>
<tr class="separator:ga73e1f2c199ec478278267f0e48b00321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa63daf944bf58af75f68db5314d996"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga1aa63daf944bf58af75f68db5314d996">xwii_iface_get_extension</a> (struct xwii_iface *dev, char **extension)</td></tr>
<tr class="memdesc:ga1aa63daf944bf58af75f68db5314d996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read extension type.  <a href="#ga1aa63daf944bf58af75f68db5314d996">More...</a><br/></td></tr>
<tr class="separator:ga1aa63daf944bf58af75f68db5314d996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9042ea6656b4cfb016aab748859ff7c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga9042ea6656b4cfb016aab748859ff7c9">xwii_iface_set_mp_normalization</a> (struct xwii_iface *dev, int32_t x, int32_t y, int32_t z, int32_t factor)</td></tr>
<tr class="memdesc:ga9042ea6656b4cfb016aab748859ff7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MP normalization and calibration.  <a href="#ga9042ea6656b4cfb016aab748859ff7c9">More...</a><br/></td></tr>
<tr class="separator:ga9042ea6656b4cfb016aab748859ff7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c38775ba36a6e7940d3ba381b444af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__device.html#ga9c38775ba36a6e7940d3ba381b444af5">xwii_iface_get_mp_normalization</a> (struct xwii_iface *dev, int32_t *x, int32_t *y, int32_t *z, int32_t *factor)</td></tr>
<tr class="memdesc:ga9c38775ba36a6e7940d3ba381b444af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read MP normalization and calibration.  <a href="#ga9c38775ba36a6e7940d3ba381b444af5">More...</a><br/></td></tr>
<tr class="separator:ga9c38775ba36a6e7940d3ba381b444af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Communication between applications and devices. </p>
<p>The device interface provides a way to communicate with a connected remote device. It reads events from the device and provides them to the application. But it also allows applications to send events to devices.</p>
<p>Note that devices cannot be connected or searched for with this API. Instead, you should use your standard bluetooth tools to perform a bluetooth inquiry and connect devices. You do the same with bluetooth keyboards and mice, don't you?</p>
<p>If you want to enumerate connected devices and monitor the system for hotplug events, you should use the <a class="el" href="group__monitor.html">monitor interface</a> or use libudev directly.</p>
<p>The device interface is split up into different sub-interfaces. Each of them is related to specific hardware available on the remote device. If some hardware is not present, the interfaces will not be provided to the application and will return -ENODEV.</p>
<p>Interfaces must be opened via <a class="el" href="group__device.html#ga432d767dc77b12aa6f86f1d784174a28" title="Open interfaces on this device. ">xwii_iface_open()</a> before you can use them. Once opened, they return events via the event stream which is accessed via <a class="el" href="group__device.html#gaadebbb6a2f7f9b579552f04ec7e06ae9" title="Read incoming event-queue. ">xwii_iface_dispatch()</a>. Furthermore, outgoing events can now be sent via the different helper functions. Some interfaces are static and don't need to be opened. You notice it if no XWII_IFACE_* constant is provided.</p>
<p>Once you are done with an interface, you should close it via <a class="el" href="group__device.html#gaca9a605d36b93af451102c03c468a9ab" title="Close interfaces on this device. ">xwii_iface_close()</a>. The kernel can deactivate unused hardware to safe energy. If you keep them open, the kernel keeps them powered up. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7d37d56ea1fb9002946bcf1863f54545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XWII_LED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num)</td><td></td>
          <td>&#160;&#160;&#160;(XWII_LED1 + (num) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create enum xwii_led constants during runtime. </p>
<p>The argument is a number starting with 1. So <a class="el" href="group__device.html#ga7d37d56ea1fb9002946bcf1863f54545" title="Create enum xwii_led constants during runtime. ">XWII_LED([num])</a> produces the same value as the constant XWII_LED[num] defined in enum xwii_led. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga781852d892d1184331701a9147497d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#ga781852d892d1184331701a9147497d91">xwii_iface_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interfaces. </p>
<p>Each constant describes a single interface. These are bit-masks that can be binary-ORed. If an interface does not provide such a constant, it is static and can be used without opening/closing it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a1d50c36edc089416557d814398f66a02"></a>XWII_IFACE_CORE</em>&nbsp;</td><td class="fielddoc">
<p>Core interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91aeaecff3a5dcd70b941a36483c6fdf6c9"></a>XWII_IFACE_ACCEL</em>&nbsp;</td><td class="fielddoc">
<p>Accelerometer interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91ad86c46c0dee8fc8755e7304a8ee5bbbb"></a>XWII_IFACE_IR</em>&nbsp;</td><td class="fielddoc">
<p>IR interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a8d9bed7f2ccad79149f6d2aff1b37081"></a>XWII_IFACE_MOTION_PLUS</em>&nbsp;</td><td class="fielddoc">
<p>MotionPlus extension interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91aa2f1390c3ed47b404b3c241632435916"></a>XWII_IFACE_NUNCHUK</em>&nbsp;</td><td class="fielddoc">
<p>Nunchuk extension interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a5ebe169cd83e389c9178e3030244c439"></a>XWII_IFACE_CLASSIC_CONTROLLER</em>&nbsp;</td><td class="fielddoc">
<p>ClassicController extension interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a55080e2c6b453a1055692d01f4e57866"></a>XWII_IFACE_BALANCE_BOARD</em>&nbsp;</td><td class="fielddoc">
<p>BalanceBoard extension interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a2fbaf95f53fb6c37418104434c690fec"></a>XWII_IFACE_PRO_CONTROLLER</em>&nbsp;</td><td class="fielddoc">
<p>ProController extension interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91a563ca6a91f8288fab92418bbcf0ef99e"></a>XWII_IFACE_ALL</em>&nbsp;</td><td class="fielddoc">
<p>Special flag ORed with all valid interfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga781852d892d1184331701a9147497d91ab6447f677b72d4842de2476921b31b1e"></a>XWII_IFACE_WRITABLE</em>&nbsp;</td><td class="fielddoc">
<p>Special flag which causes the interfaces to be opened writable. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf2498fc0f02df2f6f59632808a70b15a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__device.html#gaf2498fc0f02df2f6f59632808a70b15a">xwii_led</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LEDs. </p>
<p>One constant for each Player-LED. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa3e9517734189fe581dde3bb89e81d09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_new </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface **&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>syspath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create new device object from syspath path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dev</td><td>Pointer to new opaque device is stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syspath</td><td>Sysfs path to root device node</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new device object. No interfaces on the device are opened by default. <code>syspath</code> must be a valid path to a wiimote device, either retrieved via a <a class="el" href="group__monitor.html">monitor object</a> or via udev. It must point to the hid device, which is normally /sys/bus/hid/devices/[dev].</p>
<p>If this function fails, <code>dev</code> is not touched at all (and not cleared!). A new object always has an initial ref-count of 1.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de406d4fa9bd58c8e6bc752aaf46afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xwii_iface_ref </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase ref-count by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf92196dc992decb4e1125af750d1bfe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xwii_iface_unref </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrease ref-count by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object</td></tr>
  </table>
  </dd>
</dl>
<p>If the ref-count drops below 1, the object is destroyed immediately. All open interfaces are automatically closed and all allocated objects released when the object is destroyed. </p>

</div>
</div>
<a class="anchor" id="gae0bdc11457b4a6b84d16a4c82239b3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return file-descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object</td></tr>
  </table>
  </dd>
</dl>
<p>Return the file-descriptor used by this device. If multiple file-descriptors are used internally, they are multi-plexed through an epoll descriptor. Therefore, this always returns the same single file-descriptor. You need to watch this for readable-events (POLLIN/EPOLLIN) and call <a class="el" href="group__device.html#gaadebbb6a2f7f9b579552f04ec7e06ae9" title="Read incoming event-queue. ">xwii_iface_dispatch()</a> whenever it is readable.</p>
<p>This function always returns a valid file-descriptor. </p>

</div>
</div>
<a class="anchor" id="ga27e8f9b73053d1603033d3a4fd067101"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_watch </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>watch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Watch device for hotplug events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">watch</td><td>Whether to watch for hotplug events or not</td></tr>
  </table>
  </dd>
</dl>
<p>Toggle whether hotplug events should be reported or not. By default, no hotplug events are reported so this is off.</p>
<p>Note that this requires a separate udev-monitor for each device. Therefore, if your application uses its own udev-monitor, you should instead integrate the hotplug-detection into your udev-monitor.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga432d767dc77b12aa6f86f1d784174a28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_open </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ifaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open interfaces on this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaces</td><td>Bitmask of interfaces of type enum xwii_iface_type</td></tr>
  </table>
  </dd>
</dl>
<p>Open all the requested interfaces. If <a class="el" href="group__device.html#gga781852d892d1184331701a9147497d91ab6447f677b72d4842de2476921b31b1e">XWII_IFACE_WRITABLE</a> is also set, the interfaces are opened with write-access. Note that interfaces that are already opened are ignored and not touched. If <em>any</em> interface fails to open, this function still tries to open the other requested interfaces and then returns the error afterwards. Hence, if this function fails, you should use <a class="el" href="group__device.html#gaffb9507830c554ba34c30a053fd62baf" title="Return bitmask of opened interfaces. ">xwii_iface_opened()</a> to get a bitmask of opened interfaces and see which failed (if that is of interest).</p>
<p>Note that interfaces may be closed automatically during runtime if the kernel removes the interface or on error conditions. You always get an <a class="el" href="group__events.html#gga8ba95032bfb6f10eded001b9b7cacad2ae917df212015ee61e0b895d3c2e2f397">XWII_EVENT_WATCH</a> event which you should react on. This is returned regardless whether <a class="el" href="group__device.html#ga27e8f9b73053d1603033d3a4fd067101" title="Watch device for hotplug events. ">xwii_iface_watch()</a> was enabled or not.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaca9a605d36b93af451102c03c468a9ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xwii_iface_close </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ifaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close interfaces on this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaces</td><td>Bitmask of interfaces of type enum xwii_iface_type</td></tr>
  </table>
  </dd>
</dl>
<p>Close the requested interfaces. This never fails. </p>

</div>
</div>
<a class="anchor" id="gaffb9507830c554ba34c30a053fd62baf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int xwii_iface_opened </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return bitmask of opened interfaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a bitmask of opened interfaces. Interfaces may be closed due to error-conditions at any time. However, interfaces are never opened automatically.</p>
<p>You will get notified whenever this bitmask changes, except on explicit calls to <a class="el" href="group__device.html#ga432d767dc77b12aa6f86f1d784174a28" title="Open interfaces on this device. ">xwii_iface_open()</a> and <a class="el" href="group__device.html#gaca9a605d36b93af451102c03c468a9ab" title="Close interfaces on this device. ">xwii_iface_close()</a>. See the <a class="el" href="group__events.html#gga8ba95032bfb6f10eded001b9b7cacad2ae917df212015ee61e0b895d3c2e2f397">XWII_EVENT_WATCH</a> event for more information. </p>

</div>
</div>
<a class="anchor" id="gaa0ea234eb0b67ede2c5cb68576ddf0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int xwii_iface_available </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return bitmask of available interfaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object</td></tr>
  </table>
  </dd>
</dl>
<p>Return a bitmask of available devices. These devices can be opened and are guaranteed to be present on the hardware at this time. If you watch your device for hotplug events (see <a class="el" href="group__device.html#ga27e8f9b73053d1603033d3a4fd067101" title="Watch device for hotplug events. ">xwii_iface_watch()</a>) you will get notified whenever this bitmask changes. See the <a class="el" href="group__events.html#gga8ba95032bfb6f10eded001b9b7cacad2ae917df212015ee61e0b895d3c2e2f397">XWII_EVENT_WATCH</a> event for more information. </p>

</div>
</div>
<a class="anchor" id="gadc90a7e6d0e40c2b250c7799c7f37b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XWII__DEPRECATED int xwii_iface_poll </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxwii__event.html">xwii_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read incoming event-queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ev</td><td>Pointer where to store a new event or NULL</td></tr>
  </table>
  </dd>
</dl>
<p>You should call this whenever the file-descriptor returned by <a class="el" href="group__device.html#gae0bdc11457b4a6b84d16a4c82239b3a5" title="Return file-descriptor. ">xwii_iface_get_fd()</a> is reported as being readable. This function will perform all non-blocking outstanding tasks and then return.</p>
<p>This function always performs any background tasks and outgoing event-writes if they don't block. It returns an error if they fail. If <code>ev</code> is NULL, this function returns 0 on success after this has been done.</p>
<p>If <code>ev</code> is non-NULL, this function then tries to read a single incoming event. If no event is available, it returns -EAGAIN and you should watch the file-desciptor again until it is readable. Otherwise, you should call this function in a row as long as it returns 0. It stores the event in <code>ev</code> which you can then handle in your application.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -EAGAIN if no event can be read and <code>ev</code> is non-NULL and a negative error-code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaadebbb6a2f7f9b579552f04ec7e06ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxwii__event.html">xwii_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read incoming event-queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ev</td><td>Pointer where to store a new event or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of <code>ev</code> if <code>ev</code> is non-NULL</td></tr>
  </table>
  </dd>
</dl>
<p>You should call this whenever the file-descriptor returned by <a class="el" href="group__device.html#gae0bdc11457b4a6b84d16a4c82239b3a5" title="Return file-descriptor. ">xwii_iface_get_fd()</a> is reported as being readable. This function will perform all non-blocking outstanding tasks and then return.</p>
<p>This function always performs any background tasks and outgoing event-writes if they don't block. It returns an error if they fail. If <code>ev</code> is NULL, this function returns 0 on success after this has been done.</p>
<p>If <code>ev</code> is non-NULL, this function then tries to read a single incoming event. If no event is available, it returns -EAGAIN and you should watch the file-desciptor again until it is readable. Otherwise, you should call this function in a row as long as it returns 0. It stores the event in <code>ev</code> which you can then handle in your application.</p>
<p>This function is the successor or <a class="el" href="group__device.html#gadc90a7e6d0e40c2b250c7799c7f37b42" title="Read incoming event-queue. ">xwii_iface_poll()</a>. It takes an additional <code>size</code> argument to provide backwards compatibility.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -EAGAIN if no event can be read and <code>ev</code> is non-NULL and a negative error-code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga695ed40bc40c90a6935472dc9b4db181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_rumble </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle rumble motor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">on</td><td>New rumble motor state</td></tr>
  </table>
  </dd>
</dl>
<p>Toggle the rumble motor. This requires the core-interface to be opened in writable mode.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02ef7934408cd3938b2c4bc2d07d4d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_get_led </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>led</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read LED state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">led</td><td>LED constant defined in enum xwii_led </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>Pointer where state should be written to</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the current LED state of the given LED. <code>state</code> will be either true or false depending on whether the LED is on or off.</p>
<p>LEDs are a static interface that does not have to be opened first.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gab9d9f2430ddd7f4940feb3cbc20267f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_set_led </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>led</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set LED state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">led</td><td>LED constant defined in enum xwii_led </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>State to set on the LED</td></tr>
  </table>
  </dd>
</dl>
<p>Changes the current LED state of the given LED. This has immediate effect.</p>
<p>LEDs are a static interface that does not have to be opened first.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaea7e94790780b3bd9fd38d6f59d296d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_get_battery </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read battery state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">capacity</td><td>Pointer where state should be written to</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the current battery capacity and write it into <code>capacity</code>. This is a value between 0 and 100, which describes the current capacity in per-cent.</p>
<p>Batteries are a static interface that does not have to be opened first.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e1f2c199ec478278267f0e48b00321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_get_devtype </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>devtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read device type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">devtype</td><td>Pointer where the device type should be stored</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the current device-type, allocates a string and stores a pointer to the string in <code>devtype</code>. You must free it via free() after you are done.</p>
<p>This is a static interface that does not have to be opened first.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1aa63daf944bf58af75f68db5314d996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xwii_iface_get_extension </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read extension type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extension</td><td>Pointer where the extension type should be stored</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the current extension type, allocates a string and stores a pointer to the string in <code>extension</code>. You must free it via free() after you are done.</p>
<p>This is a static interface that does not have to be opened first.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga9042ea6656b4cfb016aab748859ff7c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xwii_iface_set_mp_normalization </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MP normalization and calibration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x-value to use or 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y-value to use or 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z-value to use or 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>factor-value to use or 0</td></tr>
  </table>
  </dd>
</dl>
<p>Set MP-normalization and calibration values. The Motion-Plus sensor is very sensitive and may return really crappy values. This interfaces allows to apply 3 absolute offsets x, y and z which are subtracted from any MP data before it is returned to the application. That is, if you set these values to 0, this has no effect (which is also the initial state).</p>
<p>The calibration factor <code>factor</code> is used to perform runtime calibration. If it is 0 (the initial state), no runtime calibration is performed. Otherwise, the factor is used to re-calibrate the zero-point of MP data depending on MP input. This is an angoing calibration which modifies the internal state of the x, y and z values. </p>

</div>
</div>
<a class="anchor" id="ga9c38775ba36a6e7940d3ba381b444af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xwii_iface_get_mp_normalization </td>
          <td>(</td>
          <td class="paramtype">struct xwii_iface *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read MP normalization and calibration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Valid device object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>Pointer where to store x-value or NULL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Pointer where to store y-value or NULL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>Pointer where to store z-value or NULL </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factor</td><td>Pointer where to store factor-value or NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Reads the MP normalization and calibration values. Please see <a class="el" href="group__device.html#ga9042ea6656b4cfb016aab748859ff7c9" title="Set MP normalization and calibration. ">xwii_iface_set_mp_normalization()</a> how this is handled.</p>
<p>Note that if the calibration factor is not 0, the normalization values may change depending on incoming MP data. Therefore, the data read via this function may differ from the values that you wrote to previously. However, apart from applied calibration, these value are the same as were set previously via <a class="el" href="group__device.html#ga9042ea6656b4cfb016aab748859ff7c9" title="Set MP normalization and calibration. ">xwii_iface_set_mp_normalization()</a> and you can feed them back in later. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 14 2013 18:27:27 for xwiimote by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
